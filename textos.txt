#Clase 2

##Introducción

Antes de poder empezar a crear aplicaciones más prácticas con nuestro código, debemos primero aprender algunas cosas más acerca del funcionamiento de Python en lo que refiere a tipos y estructuras de datos. Este conocimiento será esencial para poder crear aplicaciones de cierta complejidad.

Cuando se desarrolla un programa es usual la necesidad de trabajar con información, como fue visto en la clase anterior.
Es natural pensar que una computadora debe saber cómo es la información que tiene almacenada.

&ensp;*¿Es un número? ¿Es una letra? ¿Es una palabra? ¿Es una lista de cosas?*

<img src="https://raw.githubusercontent.com/IEEESBITBA/Curso-Python/master/_assets/Data_Type_Word_Art.png" alt = "Wordcloud con tipos de datos comunes" height = 350 title="Objects y structures son un conjunto de subtipos">


En esta ocasión vamos a profundizar sobre un aspecto en particular de dicha información el cual es llamado su "tipo". 
Mencionamos anteriormente que las variables son una forma de asignarle un nombre a un porción de la memoria de la computadora que se utiliza para guardar algún dato.

&ensp;*¿Cómo es que algunas variables representan números y otras texto?*

&ensp;*¿Cualquier porción de la memoria sirve para guardar texto o números?*

&ensp;*¿Otro tipo de información como imágenes y música se guardan en distintos lugares de la memoria?*

La memoria en una computadora en realidad funciona toda de la misma manera. De una forma muy resumida, se puede pensar a la memoria de una computadora como una larga lista de casilleros que pueden guardar números:

<br />

![Memoria diagrama 1](https://raw.githubusercontent.com/IEEESBITBA/Curso-Python/master/_assets/memoria_diagrama0.png)

<br />

Cada vez que se crea una variable, el sistema reserva algunos casilleros para guardar su información, y cada vez que se modifique el valor de la variable lo que va a suceder es que los números guardados en esos casilleros van a cambiar acordemente:

<br />

![Memoria diagrama 2](https://raw.githubusercontent.com/IEEESBITBA/Curso-Python/master/_assets/memoria_diagrama1.png)

<br />

&ensp;*¿Pero cómo podemos guardar datos que no son números?*

Ya que todas las porciones de la memoria funcionan de la misma manera, entonces debemos ser nosotros los que le den un significado distinto a los diferentes tipos de información que deseo guardar. Para guardar texto se puede asociar cada letra y símbolo a un número distinto, de esta forma uso un "casillero de memoria" para cada letra y guardo allí el número correspondiente a la letra deseada. Para guardar colores lo más usual es representarlo mediante la mezcla de los [colores primarios de la luz](https://es.wikipedia.org/wiki/Color_primario#Colores_primarios_en_la_luz_(RGB)), de forma que uso 3 números para indicar cuánto "mezclar" de cada color. De esta manera, cada tipo de información se almacena en la memoria usando una representación numérica, la cuál será distinta en cada caso:

<br />

![Memoria diagrama 3](https://raw.githubusercontent.com/IEEESBITBA/Curso-Python/master/_assets/memoria_diagrama2.png)

<br />

&ensp;*¿Cómo puedo saber si un "casillero" almacena un número, una letra, u otro tipo de información?*

Acá es donde entran en juego los "tipos" de variable. Cada variable tiene asociado un "tipo", que indica qué significan los números almacenados en la memoria bajo ese nombre, y cómo interpretarlos. De esta forma se pueden tener variables de tipo numérico, de tipo string (texto) y de muchos más que veremos más adelante. Gracias a los tipos es que puedo usar la instrucción **print()** con una variable de tipo string y la interpreta correctamente como texto, en lugar de mostrar los números que se encuentran almacenados en la memoria.

Distintos lenguajes de programación trabajan de diversas formas este aspecto de la información. En Python en particular, no se debe aclarar explicitamente cuál es el tipo de dato de una variable: el lenguaje de programación nos entiende y asume cuál debe ser dicho tipo. Por ejemplo, si creo la variable `x = 5`, no hace falta aclarar que `x` es de tipo numérico, se entiende implícitamente. Tambien a diferencia de muchos lenguajes en Python las variables no tienen un único tipo y pueden ir cambiando a lo largo de la ejecucion del programa, por esta razón se suele decir que Python es un lenguaje de tipado dinámico.

Incluímos un anexo al final de esta clase con algunos detalles más técnicos y sutilezas acerca de este tema. No es necesario leerlo, es sólo para aquel que quiera conocer más acerca del funcionamiento de la memoria.

A continuación mostraremos ejemplos con el uso de distintos tipos de dato en Python




# Link a Youtube: https://www.youtube.com/watch?v=387LGCu0ExA&ab_channel=IEEEITBA
# Tema: Tipos de datos.

from IPython.display import YouTubeVideo
YouTubeVideo('387LGCu0ExA', width=800, height=450)       

#Tipos de datos

## Tipos numéricos

# Link a Youtube: https://www.youtube.com/watch?v=JHryjYQncMY
# Tema: Tipos de datos numericos, int, float y bool.

from IPython.display import YouTubeVideo
YouTubeVideo('JHryjYQncMY', width=800, height=450)       #Video Clase 2.1

### int
Es el tipo de dato más básico, en donde pueden almacenarse números enteros:

dias = 5
print(dias)

A veces operando con datos enteros podemos obtener números racionales, por ejemplo:

x = int(input("Ingrese dividendo:"))
y = int(input("Ingrese divisor:"))
print("Resultado:", x/y) 

Para evitar esto podemos usar el operador **división entera: //** para obtener la parte entera del resultado de la división:

x = int(input("Ingrese dividendo:"))
y = int(input("Ingrese divisor:"))
print("Resultado división entera:", x//y) 


Si queremos saber el resto de la división entera, usamos el operador **módulo %** que fue explicado previamente:

x = int(input("Ingrese dividendo:"))
y = int(input("Ingrese divisor:"))
print("División entera=", x // y) # Redondea division hacia abajo
print("Resto =",x % y)            # Operación Módulo

#Se pueden mostrar varias cosas juntas si se separan con coma dentro de print()
print(x // y, "*", y, "+", x%y,"=", x)

### float
Este tipo de dato es utilizado para almacenar números reales que pueden contener decimales.

pi = 3.14
x = 3.    # Se indica que es un numero real con el . 
z = 3     # Este será un número entero
print("x =", x)
print("z =", z)

Si queremos saber la parte entera de un float, podemos simplemente convertirlo a **int**.
La acción de convertir una variable de un tipo a otro diferente se la conoce como **cast**. Esto hará la siguiente operacion:

$$x \leftarrow \lfloor y \rfloor $$

y = 3.14
x = int(y)
print("x =", x)

Para que el usuario ingrese un número real (de tipo float) usando *input()* debemos realizar un **cast** con la instrucción **float()**

real = float( input() )
print("El doble del numero ingresado =", real*2)

Es importante tener en cuenta que los *float* no pueden ser infinitamente precisos. Cada variable que usamos se guarda en memoria, pero... *¡Para infinita precisión necesitaríamos infinita memoria!* Es entonces que los números con decimales suelen tener una diferencia muy pequeña con el valor que realmente deseamos.

Por esto suele ser preferible cuando trabajamos con *floats*, realizar comparaciones del tipo `>` ó `<`, en lugar de `==` ó `!=` porque pueden surgir problemas.

¿Cuál es el problema de estos programas?

a = 1/3
b = 2/3
c = a + b

print(c-b == a)

# Nunca va a terminar. Usar con cuidado!

var = 0.11
while var is not 0:
    print(var)
    var -= 0.01

Muchas veces es necesario redondear un número decimal, ya sea para obtener un número entero o un número con menor cantidad de decimales. Esto se puede lograr con el comando **round()**, el cual permite indicar la cantidad de decimales a redondear. Si no se indica la cantidad de decimales asume por defecto que el resultado será un número entero.

x = round(1234.56)
y = round(1234.56789, 2)
z = int(8.9)

print(x, y, z)

#### **Mini-desafío:** floats
Crear: 
*   Una función que convierta grados **Celsius** a grados **Farenheit** (https://es.wikipedia.org/wiki/Grado_Fahrenheit)
*   Una función que convierta grados **Celsius** a grados **Kelvin** (https://es.wikipedia.org/wiki/Kelvin)

\
<img height="200" src="https://raw.githubusercontent.com/IEEESBITBA/Curso-Python/master/_assets/termometro.png">


El usuario debe ingresar una temperatura en grados Celsius y el programa debe mostrar las conversiones a Farenheit y Kelvin utilizando las funciones. Si la temperatura ingresada es inferior al [cero absoluto](https://es.wikipedia.org/wiki/Cero_absoluto), el programa debe mostrar un mensaje de advertencia.

Pueden leer [aquí](https://en.wikipedia.org/wiki/Conversion_of_units_of_temperature) sobre como hacer las conversiones.



### boolean
Es un tipo de dato que puede tomar dos valores distintos, **True** (Verdadero) o **False** (Falso)

llueve = False
soleado = True
print(not llueve == soleado)

Ya veníamos usando este tipo de datos implícitamente: las comparaciones devuelven booleanos.

Prácticamente cualquier dato puede *cast-earse* (convertirse) a boolean. Para los números, 0 es False y cualquier otro es True. Para otros datos, en general son False si están "vacíos" y True en los demás casos.

print(bool(4))
print(bool(6435645))

print(bool("hola"))
print(bool(""))

print(int(True))
print(int(False))


palabraTrue = str(True)
palabraFalse = str(False)
print(palabraTrue)
print(palabraFalse)

##Tipo texto: string

# Link a Youtube: 
# Tema: Strings, qué son, operaciones y sus métodos.

from IPython.display import YouTubeVideo
YouTubeVideo('PthbaJSEk4c', width=800, height=450)       #Video Clase 2.2

Los strings son un tipo de dato utilizado para guardar letras, palabras, oraciones, texto, etc.

nombre = "Juan"
apellido = 'Lopez'

¡También podemos convertir strings a números y viceversa! Así podemos operar con ellos. 

nombre = "3"
numero = 3

print(nombre == numero)
print(nombre == str(numero))
print(nombre * 4)
print(numero * 4)

Vale la pena notar cómo un operador puede realizar una operación para un tipo de dato y otra para otro tipo. Como se ve en el ejemplo anterior, cuando se multiplican enteros se realiza lo que naturalmente conocemos como multiplicación. En cambio, si multiplicamos un string por un número lo que se hace es concatenar la string tantas veces como lo indique el multiplicador.

### Operaciones con strings

Se pueden realizar muchas operaciones con strings que serán se suma utilidad, por ejemplo:

- **x+y**: En esta operacion se agrega al final de la string x el contenido de y.

x = 'ho'
y = 'la'
print(x + y)
print(y + x)

 - **len**( $string$ ): Obtiene el tamaño de un string.

x = "Hola"
y = 'Adios'

print( len(x) )
print( len(y) )

 - **.startswith**( $algo$ ): Le preguntamos a la string si empieza con cierto texto.

x = 'hola'
print(x.startswith('h'))
print(x.startswith('x'))

 - **.endswith**( $algo$ ): Le preguntamos a la string si termina con cierto texto.

x = 'hola'
print(x.endswith('h'))
print(x.endswith('a'))

 - **[ *índice* ]**: Se pueden obtener letras de un string. Entre corchetes se indica el *índice* de la letra deseada, empezando a contar desde cero.

x = 'hola'

print(x[0])
print(x[1])
print(x[2])
print(x[3])

print(x[3]+x[2]+x[1]+x[0]+x[3])

* **.replace**(*string_viejo*, *string_nuevo*, *cantidad*): Cada vez que aparece el *string_viejo* dentro del texto, se reemplaza por el *string_nuevo*. Adicionalmente se puede especificar la *cantidad* de veces que se realizará un reemplazo.

x = "acalambrar"
y = x.replace('a', 'e', 2)
z = x.replace('a', 'e')
print(y)
print(z)

 - **[ *comienzo* : *fin* ]**: Se puede obtener una secuencia consecutiva de letras de un string. Entre corchetes se indica el índice de la primer letra deseada, luego dos puntos, luego el índice de la última letra (la última letra no será incluída).

x = 'programacion'

# Ayudín:
#  p   r   o   g   r   a   m   a   c   i   o   n
#  0   1   2   3   4   5   6   7   8   9   10  11
# -12 -11 -10 -9  -8  -7  -6  -5  -4  -3  -2  -1

print( x[0:8] )
print( x[4:8] )

# Se pueden usar signos negativos para referir los índices desde el final para atras
print( x[-7:-4] )

# Se puede omitir el parametro de fin para seguir hasta el final
print( x[8: ])

# Se puede omitir el parametro de inicio para comenzar desde el principio
print( x[ :8])

 - **[ *comienzo* : *fin* : *salto* ]**: Se puede obtener una secuencia de letras a una separación regular de un string. Entre corchetes se indica el índice de la primer letra deseada, luego dos puntos, luego el índice de la última letra, luego 2 puntos, luego el salto entre letra y letra (la última letra no será incluída).

x = 'Curso de Python'

print( x[0:5:2] )

# Se pueden usar signos negativos para referir los índices desde el final para atras
# Se puede omitir el parametro de inicio para comenzar desde el principio
# Se puede omitir el parametro de fin para seguir hasta el final
print( x[0: :3] )

# Se puede usar un salto negativo para recorrer el string en sentido inverso
print( x[11:1:-2] )
# Se puede invertir un string de la siguiente forma
print( x[ : :-1] )

### for sobre un string
La estructura *for* que vimos la clase pasada tiene una gran versatilidad ya que como veremos, no está limitada a recorrer los valores generados por *range()*. También es posible recorrer los caracteres de un string usando *for* como se muestra a continuación:

texto = "Curso de Python"
vocales = 0
for c in texto:
  if c == 'a' or c == 'e' or c == 'i' or c == 'o' or c == 'u':
    vocales += 1

print("Vocales: ", vocales)

#### **Mini-desafío:** Operaciones con strings
Hacer un programa que permita ingresar un nombre y un apellido usando dos veces la función input( ). Luego debe crear la variable *nombre_y_apellido* que contenga ambos datos separados por un espacio. Un fabricante de tarjetas admite la impresión de hasta 26 caracteres para el nombre del dueño de la tarjeta, el programa debe imprimir "Nombre admitido" si *nombre_y_apellido* cumple con esta restricción y "Nombre no admitido" en caso contrario (el espacio cuenta como uno de los 26 caracteres disponibles).

\
<img height="150" src="https://raw.githubusercontent.com/IEEESBITBA/Curso-Python/master/_assets/credit_cards.png">


**Para un desafío mayor:** Si *nombre_y_apellido* cumple la restricción, mostrar el nombre y apellido. En caso contrario *nombre_y_apellido* debe valer la inicial del nombre y luego el apellido separado por un espacio. Si todavía no se cumple la restricción entonces el valor será la inicial del nombre y las primeras 24 letras del apellido. Mostrar el nombre resultante.



### Métodos

Podemos observar que algunas de las operaciones con strings que vimos funcionan de una manera diferente a las que usamos hasta ahora. Por ejemplo, para usar **.startswith( )** debemos escribir la instrucción separada por un punto luego de la variable:

```python
nombre = "juan"
print( nombre.startswith('j') )
```

Este tipo de instrucción se la denomina un *método* (se utiliza con un punto luego de un objeto). La diferencia entre este y una función es sutil, el concepto es que un método es aplicado *sobre* un elemento. Tengo un elemento, como puede ser una variable de tipo string, y sobre ese elemento efectúo cierta acción. Los métodos pueden recibir parámetros, como es en el caso anterior la letra a evaluar.

Es normal que todavía no quede clara realmente la diferencia con las funciones, pero a medida que avanza el curso se encontrarán con más métodos e irán adquiriendo este criterio de a poco.

Python nos provee de muchos métodos distintos para todos los tipos de variables. Nadie conoce todos, ni siquiera los que programaron en Python toda su carrera, por lo cual nunca teman buscar qué métodos existen ya que puede ser que haya uno que resuelva prefectamente su problema.

Esta es una lista de los métodos que existen para strings: https://docs.python.org/3/library/stdtypes.html#string-methods


#Estructuras de datos

Utilizando variables de los distintos tipos de datos como los mostrados anteriormente se pueden armar programas con una complejidad notable. Sin embargo, hay un límite en la versatilidad del programas si sólo utilizamos los tipos de datos que vimos hasta ahora.

<img src="https://raw.githubusercontent.com/IEEESBITBA/Curso-Python/master/_assets/data_structures.png" alt = "Visualización básica de una data structure" height = 280 title="Las estructuras de datos son un concepto muy importante para cualquier lenguaje de programacion">


Se suele llamar "estructura de datos" a cierta clase de tipos de datos más complejos, los cuales nos permiten organizar la información de manera más efectiva. 

En particular, nos permiten agrupar datos (cada uno de ellos con su tipo), e interactuar con ellos de la forma más apropiada. 

A continuación mostraremos la estructura de datos más sencilla (¡pero útil!) que Python nos ofrece, y en la próxima clase veremos otras estructuras algo más complejas.

# Listas


# Link a Youtube: 
# Tema: Listas, cómo estan construidas, operaciones y métodos.

from IPython.display import YouTubeVideo
YouTubeVideo('RjoEiJcyV_U', width=800, height=450)       #Video Clase 2.1

Las listas nos permiten almacenar elementos de manera secuencial, los cuales pueden ser accedidos mediante el conocimiento de su posición en la lista. Estas las creamos usando corchetes de la siguiente manera:

> a = **[** $ a_{0}, a_{1}, a_{2}, \dots $ **]**

A continuación se mostrara un ejemplo sencillo con listas:

# Creamos una lista con elementos
a = [ 13, 40, 10, 30, 67 ] 
print(a)

# Creamos una lista vacía
b = []
print(b)

# Creamos una lista vacía
c = list()
print(c)

Para acceder a un elemento de una lista se utiliza `lista[índice]` de forma similar a como funcionan los strings.
Podemos modificar el elemento asignándole un valor.

Al igual que los strings, las listas permiten hacer **slicing**. Esto significa obtener una sub-lista a partir de valores de comienzo, fin y step indicados entre corchetes y separados por dos puntos.

a = [5, 6, 7, 8]
print('a =', a)
print('a[0] =', a[0]) 
print('a[2] =', a[2])

a[2] = 0
print('a =', a)

# Se pueden intercambiar dos elementos de una lista de la siguiente forma
a[0], a[1] = a[1], a[0]
print('a =', a)

# Se pueden usar signos negativos para referir los índices desde el final para atras
print('a[-1] =', a[-1]) 

# Slicing
print('a[1:3] =', a[1:3])    

# Se puede omitir el parametro de inicio para comenzar desde el principio
# Se puede omitir el parametro de fin para seguir hasta el final
# Se puede usar un salto negativo para recorrer la lista en sentido inverso
# Se puede invertir una lista de la siguiente forma
print('a[ : :-1] =', a[ : :-1] )

Notar que, a diferencia de lo que diría el sentido común, el primer elemento de la lista se accede con el índice $0$. Esto sucede en muchos lenguajes de programación hoy en día y una vez que uno se acostumbra resulta muy práctico empezar a contar desde $0$ para aplicaciones de programación.

Otro tema a tener en cuenta es que no es posible ponerle el nombre *list* a una lista, ya que es una palabra reservada. Esta es una función para generar una lista a partir de otro objeto, como un string. Por ejemplo:

texto = "Hola"
lista = list(texto)

print(texto)
print(lista)

Una forma alternativa de generar una lista es utilizando la instrucción *for* dentro de los corchetes de la siguiente manera:

> b = **[** x **for** x **in** **range**(N) **]**

b = [x for x in range(10)]
print(b)


Podemos también aplicar una operación a la variable x
> a = **[** (operacion con x) **for** x **in** **range**(N) **]**

a = [ x for x in range(0, 101)]
print(a)

b = [ x*2 for x in range(15)]
print(b)

También es posible utilizar un objeto iterable, en lugar de usar **range( )**.

c = [3 * letra for letra in "hola"]
print(c)

d = [ 10+n for n in [1,2,3,4] ]
print(d)

#### **Mini-desafío:** Listas
1. Crear una lista con los números pares menores a 50.
2. Crear un programa en el cual el usuario ingresa un *string* y dos índices numéricos. El programa debe crear una lista a partir de las letras del string, luego intercambiar dos letras de lugar a partir de los índices indicados por el usuario. Por último debe combinar las letras de la lista nuevamente en un *string* e imprimir el resultado. Si los índices son inválidos mostrar un mensaje de error.

 **Tips**:
 - Usando `list( mi_string )` pueden obtener una lista que contiene las letras de `mi_string`.
 - Usando el método [str.join()](https://docs.python.org/3/library/stdtypes.html#str.join) pueden unir las letras o strings de una lista dentro de un mismo string:
 ```python
 lista = ["Uno", "Dos", "Tres"]
 texto = "".join( lista )
 ```
 A la izquierda del `.join()` se indica el string con el cual unir los elementos como por ejemplo `", "`. Si utilizamos un string vacío no intercala ningún caracter entre los elementos.


# Parte 1


# Parte 2


## Operaciones sobre una lista
Podemos realizar múltiples operaciones sobre una lista:

- **a+b**: Al igual que los strings se agrega el contenido de **b** al final de **a**.

a = [1,2]
b = [3,4]
z = a+b
print(z)

- **len**( $lista$ ) Obtiene el largo de una lista.

a = [1,2,3,4]
print(len(a))

- **.sort**(): Ordena los elementos de la lista.

a = ["Hola", "Adios", "Como esta", "Buen día" ]
a.sort()
print(a)

b = [1, 2, 3, 123, 23, 12]
b.sort()
print(b)

# Es posible hacer un orden inverso indicando reverse=True
b.sort(reverse=True)
print(b)

Es posible definir una regla de ordenamiento personalizada. Se debe definir una función, la cuál será evaluada en cada elemento de la lista, y el resultado de esta función se usa como criterio de orden. En la función *sort* se debe ingresar como parámetro *key=nombre_de_funcion*.

# En este ejemplo la regla es la longitud del elemento
def mi_orden1(e):
  return len(e)

a = ["Hola", "Adios", "Como esta", "Buen día" ]
a.sort(key=mi_orden1)
print("Orden final:", a)

# En este ejemplo se analiza el segundo valor de cada elemento
def mi_orden2(e):
  return e[1]

area = [ ["Argentina", 2.78], ["Brazil", 8.51], ["Mexico", 1.96] ]
area.sort(key=mi_orden2)
print("Orden final:", area)

- **.append**($algo$): Permite agregar un elemento al final de la lista.

mensaje = "Hola como estas"
v = [50, mensaje, 150.5, True]
print(v)

# Agrego al final de la lista un elemento que vale 200 (tipo int)
v.append(200)      

# Agrego una lista de elementos
# Los elementos de la lista no son agregados individualmente
# En cambio, la lista se agrega como un elemento en sí misma
v.append(["Uno", "Dos", "Tres"]) 
print(v)

- **.extend**($lista$): Permite agregar elementos de una lista al final de otra. Es muy similar a la suma de listas.

v = [1, 2, 3]
v.extend(["Uno", "Dos", "Tres"]) 
print(v)

- **.pop**(): Permite remover el ultimo elemento de la lista.

v = ["Uno", 2, "Tres", 4, "Cinco"]
v.pop() # Quito el ultimo elemento 
print(v)

- **.remove**($valor$): Remueve el primer elemento de la lista cuyo valor sea el indicado.

v = [1,2,1,2]
v.remove(2) # elimino el primer valor igual a 2
print(v)
v.remove(2) # elimino el primer valor igual a 2
print(v)

- **del** lista**[*índice*]**: Para eliminar un elemento en una posición determinada.

a = ["hola","como","estas"]
del a[1]
print(a)

- $algo$ **in** lista: Muchas veces es necesario saber si un elemento esta dentro de una lista, para ello utilizamos esta estructura.


x = [1,2,3]
if 5 in x:
    x.remove(5)
else:
  print(5,'no esta en la lista')
  
print(x)

- **max**($lista$): Obtiene el valor más alto de la lista.

valor = max( [1, 2, 3, 4, 5, 4, 3, 2, 1] )
print(valor)

valor = max( ["Curso", "De", "Python"] )
print(valor)

- **min**($lista$): Obtiene el valor más bajo de la lista.

valor = min( [1, 2, 3, 4, 5, 4, 3, 2, 1] )
print(valor)

valor = min( ["Curso", "De", "Python"] )
print(valor)

## for sobre una lista
Al igual que con strings, la instrucción *for* puede ir avanzando sobre todos los elementos de una lista:

lista = [1, 10, 100, 1000, [5,6,7], 5, "hola"]

for elemento in lista:
    print(elemento)

#### **Mini-desafío:** Operaciones sobre una lista
Realizar un programa que ordena nombres alfabéticamente. Primero debe pedir al usuario que ingrese un número, la cantidad de nombres que serán ingresados. Luego debe pedir al usuario que ingrese un nombre y repetir ese pedido la cantidad de veces indicada. Los nombres se deben ir agregando a una lista. Por último, ordenar la lista alfabéticamente y mostrar en pantalla de a uno por vez los nombres ordenados (usando un for).



## Para pensar: ¿Cómo se podría hacer una matriz usando listas?

# Esto se puede lograr con listas que contengan listas
# Cada elemento de la lista exterior corresponderá a una de las filas de la matriz
# En este caso habría que procurar que todas las listas interiores tengan la misma longitud

x = [[1,2,3],
     [4,5,6],
     [7,8,9]]

print(x[1][2])

## Nota final
Es importante observar que en las listas los elementos se almacenan en un orden bien definido, es decir: siempre hay un elemento que está antes y otro que está después. Esto no será siempre cierto con otras estructuras de datos. 

Otro detalle es que es posible crear listas con elementos de cualquier tipo de dato, o con cualquier estructura de datos. De forma que se pueden crear listas de listas, o cualquier otra combinación de las estructuras que veremos más adelante.

Mas información acerca de los métodos de una lista: https://docs.python.org/3/tutorial/datastructures.html#more-on-lists


# Manipulación de archivos de texto


La manipulación de archivos es muy común en el ámbito de la programación. En esta ocasión comenzaremos a manipular archivos de texto, dado que son simples y muy usados. En otros cursos más avanzados se manipulan archivos más complejos, como hojas de datos, por lo cual esta explicación les puede servir como una introducción que les será de utilidad en el futuro.

<img src="https://icons-for-free.com/iconfiles/png/512/document+file+page+paper+programming+icon-1320165844326114116.png" height=200>

A veces es necesario realizar un programa que pueda procesar información que se encuentra en un formato "particular", en tales casos necesitamos realizar un programa especializado. El análisis de un texto es un ejemplo de un archivo para el cual necesitamos realizar una lectura en modo "manual". 



## Lectura de archivos

# Link a Youtube: https://youtu.be/88fS3hbKV-Q
# Tema: Lectura de archivos de texto.

from IPython.display import YouTubeVideo
YouTubeVideo('88fS3hbKV-Q', width=800, height=450) 

Imaginemos que se necesita leer un archivo **.txt** con una noticia del diario y analizar su contenido. 

<img src="http://www.harfordcountyhealth.com/wp-content/uploads/2015/01/Newspaper.jpg" width=300>

A continuación mostraremos un ejemplo donde se accede a la información de un archivo llamado **noticia.txt**. Normalmente desde nuestra computadora podremos acceder a los archivos *locales* conociendo su ubicación en el disco, es decir que en tanto se conozca la carpeta donde se ubique el archivo este se podrá abrir. Colab requiere cargar los archivos a su entorno online antes de poder usarlos, lo cual se puede realizar mediante el siguiente comando, que descarga un archivo de internet y lo carga al entorno de Colab:

# Comando wget. Sólo para maquinas Linux. Google Colab usa Linux!
! wget "https://raw.githubusercontent.com/IEEESBITBA/Curso-Python/master/Curso_Introductorio_Datos/noticia.txt"

# Si no estamos en un entorno linux podemos definir nuestra propia wget
# Esta función nos ayuda a descargar archivos desde la web, no es necesaria para archivos locales
# No es necesario entender cómo funciona, se las mostramos sólo por si alguno llega a necesitarla

# Importamos la libreria requests (luego veremos qué es una librería)
import requests

def wget(url):
    r = requests.get(url, allow_redirects=True)
    with open(url[url.rfind('/') + 1::], 'wb') as f:
        f.write(r.content)

wget("https://raw.githubusercontent.com/IEEESBITBA/Curso-Python/master/Curso_Introductorio_Datos/noticia.txt")

En este caso abriremos el archivo con el comando **open( )** de Python y guardamos el contenido "en bruto" en una lista de strings, separando por renglones. Si el archivo se encuentra en la misma carpeta que el programa en Python alcanza con indicar el nombre del archivo. En caso contrario, es necesario indicar la ubicación del mismo entre los paréntesis de **open( )**.

Para obtener una lista de renglones en el archivo utilizamos un *método* llamado **readlines( )**.

Pueden encontrar otros métodos útiles en [este link](https://www.w3schools.com/python/python_ref_file.asp).

file = open("noticia.txt") # Guardamos el contenido del archivo en una variable

contenido = file.readlines() # Obtenemos una lista de renglones
print(contenido)

for line in contenido: 
    print(line) # Mostramos renglón a renglón

Luego de poder almacenar el contenido, lo separaremos por palabras utilizando el método **.split()**

palabras = []

for line in contenido:
    
    palabras_linea = line.split(' ') # Separamos por espacios
    
    for palabra in palabras_linea:   # por cada "string" separado por espacios
        palabras.append(palabra)

print(palabras)

¡Podemos observar que algunos carácteres no deseados se filtran entre las palabras (como `\n` ó `"`)! Es habitual que cuando analizemos un archivo a mano de manera "personalizada" ocurran esta clase de problemas, los cuales debemos resolver con algunos parches a nuestro programa. En este caso los carácteres no deseados que podemos observar a simple vista son: `\n` `"` `,` `.`. Los caracteres que tienen la barra invertida *\* son llamados '*secuencias de escape*' o '*escape characters*' y se utilizan para definir ciertos caracteres especiales dentro de strings, por ejemplo `\n` es el caracter de nueva línea, esto vendría a ser lo que se almacena en memoria cuando apreto la tecla *Enter*. Los filtraremos utilizando el comando [replace](https://www.geeksforgeeks.org/python-string-replace/) de python:

palabras = []

for line in contenido:
    
    # eliminamos los distintos carácteres no deseados uno por uno
    line = line.replace('\n','')
    line = line.replace('"','')
    line = line.replace(',','')
    line = line.replace('.','')
   
    palabras_linea = line.split(' ') # separamos por espacios 
    
    for palabra in palabras_linea: # por cada "string" separado por espacios
      if palabra != '':
        palabras.append(palabra)

print(palabras)

Podríamos hacer el código un poco más simple con una lista de caracteres indeseados. Una idea muy útil es pasar todo el texto a mayúsculas para poder analizar el texto de manera más simple. Por ejemplo, si quiero buscar una palabra no tendré que analizar la posibilidad de que la primera letra sea mayúscula y el resto no.

palabras = []
no_deseado = ['\n', '"', ',', '.']

for line in contenido:
    
    # eliminamos los distintos carácteres no deseados uno por uno
    for caracter in no_deseado:
      line = line.replace(caracter,'')
   
    palabras_linea = line.split(' ') # separamos por espacios 
    
    for palabra in palabras_linea: # por cada "string" separado por espacios
      if palabra != '':
        palabras.append(palabra.upper()) # convertimos todo a mayuscula

print(palabras)

#### **Mini-desafío:** Archivos de texto
Encontrar la cantidad de ocurrencias de la palabras "**cráter**" y "**que**" en el texto de la noticia.



## Escritura de archivos

# Link a Youtube: https://youtu.be/AGw1A4L3Bhs
# Tema: Escritura de archivos de texto.

from IPython.display import YouTubeVideo
YouTubeVideo('AGw1A4L3Bhs', width=800, height=450) 

El comando **open( )** tiene la posibilidad de recibir un segundo parámetro indicando el *modo* en el que abre el archivo:

- `"r"` - Read (valor por defecto). Abre el archivo para ser leído y produce un error si el archivo no existe.

- `"a"` - Append - Abre el archivo para 'concatenar', es decir agregar nuevo contenido al final de lo que ya existe, y crea un archivo nuevo si no existe.

- `"w"` - Write - Abre el archivo para escritura, y crea un archivo nuevo si no existe.

- `"x"` - Create - Crea el archivo especificado, y produce un error si el archivo ya existe.

Existen otros modos como `"r+"`, `"rb"`, `"w+"`, `"wb"` los cuales pueden encontrar en la documentación de Python.

Es una buena práctica "cerrar" el archivo luego de que haya sido abierto. Esto se logra con el método **close( )** y se debería utilizar siempre que el archivo termine de ser usado.

file = open("nuevo_archivo.txt", "w")
file.write("Uno ")
file.write("Dos ")
file.write("Tres!")
file.close()

file = open("nuevo_archivo.txt", "r")
print( file.readlines() )
file.close()

En Google Colab el archivo queda guardado en la pestaña *Archivos*. Si usan un entorno de desarrollo distinto el archivo será guardado en su disco de la computadora. Para ver el archivo generado pueden seguir los siguientes pasos:

<img src="https://raw.githubusercontent.com/IEEESBITBA/Curso-Python/master/_assets/colab_archivos_2.png" width=400>



Como mencionamos brevemente, existen *caracteres de escape* especiales. Por ejemplo `\n` representa lo que hace la tecla 'Enter', crear una nueva línea. Al momento de crear un archivo podemos utilizar este caracter para escribir en diferentes renglones:

file = open("renglones.txt", "w")
file.write("Este es el primer renglón.\n")
file.write("Este es el segundo renglón.\n")
file.write("Este es el tercer renglón.\n")
file.write("Adiós!\n")
file.close()

file = open("renglones.txt", "r")

for renglon in file.readlines():
  print(renglon)
  
file.close()

Al final de la clase podrán encontrar a modo de anexo, fragmentos de transmisiones en vivo de años anteriores que podrían ser de su interés.

La lectura de los Anexos es **100% opcional** y NO es un requisito para continuar con el curso.

# $\color{\green}\blacktriangleright$ Desafío a Entregar: Ahorcado

*Los desafíos se entregan mediante [esta página](https://www.hackerrank.com/2021-1c-curso-introductorio-de-python) de HackerRank. Pueden ver un instructivo acerca del uso de la plataforma en [este link](https://youtu.be/pqYSwABnS_k).*

Les proponemos programar el famoso juego "Ahorcado" donde un jugador ingresa una palabra y otro jugador intenta adivinarla. En cada turno, el segundo jugador indica una letra que cree que se encuentra en la palabra elegida.

Una vez que el segundo jugador adivina todas las letras que se encuentran en la palabra, el juego termina y se muestra la cantidad de intentos que fueron necesarios. En el caso de que la cantidad de intentos errados supere cierto límite, el juego termina y el segundo jugador pierde. En esta versión del juego, si se adivina una letra que aparece varias veces en la palabra, todas las ocurrencias cuentan como adivinadas.

**Formato del input:**

 * Primero se recibe la palabra que se debe adivinar (en mayúsculas).
 * Luego se recibe un número $N$, la cantidad máxima de intentos errados.
 * Por último se recibe cierta cantidad de letras en mayúsculas, una por línea, sin repetir.

**Formato del output:**  

 * En caso de que se haya adivinado la palabra antes de superar el límite $N$, se imprime la cantidad de intentos que tardó en adivinar.

 * En caso de que se haya **superado** el límite $N$, se imprime el número $0$.

**Ejemplos:**

* Ejemplo 1

  *Input:*
 
  ```python
  PYTHON
  3
  A
  B
  C
  P
  Y
  T
  H
  O
  N
  ```
 *Output:*
  ```python
  9
  ```
  Si bien el jugador tuvo tres intentos erróneos (```'A','B' y 'C'```), adivinó la palabra antes de equivocarse la cuarta vez y es por ello que se cuenta como partida ganada. A su vez, notar que el programa imprime la cantidad de turnos que se tardaron en adivinar la palabra.
  
* Ejemplo 2:

  *Input:*
 
  ```python
  IEEE
  3
  A
  B
  C
  D
  ```
 *Output:*
  ```python
  0
  ```
  El jugador pierde ya que supera los 3 intentos errados (```'A', 'B', 'C' y 'D'```) antes de adivinar las letras ```'I' y 'E'```.

\

**Tip:** Pueden eliminar todas las ocurrencias de cierto caracter en un string utilizando el método **.replace()**:

```python
palabra = palabra.replace( "A", "" )
```



$\medio$ *Challenge (No se entrega en la corrección automática)*:

 * Mostrar un contador de letras incorrectas, incrementarlo si la letra no esta en la palabra.
 * Mostrar la palabra con guiones bajo ```_``` en donde haya una letra que el jugador todavía no adivino y mostrar las letras que sí adivino. Por ejemplo para la palabra *AHORCADO* debe mostrar: ```A _ O _ _ A _ O ``` si el jugador ya ingreso las letras `A`, `O` y `P`.    
 * Armar una representación de la persona ahorcada del juego usando [Arte ASCII](https://es.wikipedia.org/wiki/Arte_ASCII), si prefieren pueden usar los dibujos ya creados por otras personas en internet.



# Ejercitación integradora $\newcommand{\dif}{\bigstar}$$\newcommand{\facil}{\color{\green}{\dif}}$ $\newcommand{\pieceofcake}{\color{\cyan}{\dif}}$$\newcommand{\medio}{\color{\yellow}{\dif\dif}}$$\newcommand{\media}{\medio}$$\newcommand{\normal}{\medio}$  $\newcommand{\dificil}{\color{\orange}{\dif\dif\dif}}$ $\newcommand{\imposible}{\color{\red}{\dif\dif\dif\dif}}$
$\newcommand{\tarc}{\large\frown}$
$\newcommand{\arc}[1]{\stackrel{\tarc}{#1}}$
<head>
<style type="text/css">
  .img{ 
    display: block;
    margin-left:auto;
    margin-right:auto;
  }
  </style>
  </head>

A continuación les proponemos resolver algunos ejercicios integradores, este contenido servirá para poder practicar lo aprendido y de a poco acercarse a lo que podría ser una aplicación real. No se preocupen si no llegan a terminar todos, o si les cuestan más que los desafíos de la clase, es cuestión de tomarse el tiempo de leer, pensar, y probar diferentes ideas hasta que encuentren una posible solución al problema.

Luego de una semana les enviaremos una copia de las soluciones que se nos ocurrieron a nosotros para resolver estos problemas y poder comparar en caso de que lo deseen.

### $\facil$ Call me $\frac{\partial}{\partial x}$, or $\mathrm{diff}$ for short
Una operacion muy común al manejar datos es la derivada

$$ \frac{d }{dt} (\mathrm{Datos}) $$

Escribir una función que reciba una lista de precios diarios de las acciones de una compañía. Llamemos $n$ a la cantidad de elementos en esta lista. Debe devolver una lista de tamaño $n-1$ con los valores de la *derivada discreta* de la lista recibida.

La *derivada discreta* corresponde a la diferencia entre un elemento y su anterior, podemos usar la siguiente definición:
* $\mathrm{derivada}[i]=x[i+1]-x[i]$ 

Indicar el día en el cual se produjo el mayor salto positivo en el precio de las acciones, y el día en el cual se produjo el mayor salto negativo.

**Tip:** Las instrucciones **max()**, **min()**, y **.index()** les pueden ser de gran utilidad.



### $\facil$ ¿Acaso hubo buhos aca?

Definir una función que detecte si una palabra es un [palíndromo](https://es.wikipedia.org/wiki/Pal%C3%ADndromo) y devuelve `True` ó `False`.

**Ejemplos:**

`palindromo( "python" )` → `False`

`palindromo( "reconocer" )` → `True`

`palindromo( "Neuquén" )` → `False` (La tilde y la N mayúscula hacen que el resultado sea falso)

\

$\medio$ *Challenge*: Modificar la función para ignorar espacios, signos de puntuación, y que no haga distinción entre mayúsculas y minúsculas (pueden usar [str.lower](https://docs.python.org/3/library/stdtypes.html?highlight=str.lower#str.lower) o [str.upper](https://docs.python.org/3/library/stdtypes.html?highlight=str.lower#str.upper)). Sugerimos usar el nombre del desafío como un palindromo de ejemplo:

  `palindromo( "¿Acaso hubo buhos aca?" )` → `True`




### $\facil$ Entre Paréntesis

En este desafío deben programar un [linter](https://en.wikipedia.org/wiki/Lint_(software)) que verifique la correcta utilización de los paréntesis en un texto.

La entrada del programa será un texto, que puede contener paréntesis `()` además de cualquier otra letra o símbolo. Su tarea es determinar que el texto sea válido, lo cual en este caso quiere decir que la utilización de paréntesis es correcta, cada símbolo de apertura se corresponde con uno de cierre. Se debe imprimir `True` o `False` en función de si el texto es válido o no.

**Ejemplos:**

- Cada paréntesis se cierra en el orden correcto:

  ```python
  esCorrecto( "Yo (Juan) quiero (necesito) café." ) → True
  ```

- Falta cerrar el paréntesis ``)``:

  ```python
  esCorrecto( " (1*(2+3) " ) → False
  ```

- Falta abrir el paréntesis ``(``:

  ```python
  esCorrecto( " )(()) " ) → False
  ```

- Se cierran en el orden incorrecto:

  ```python
  esCorrecto( " ( ) ) ( ( ) " ) → False
  ```



###$\medio$ Las naranjas de Miguel 
Miguel vive en un pueblo frutero con su hermana en el valle de Oz. Todos los días cosecha bananas y naranjas de su campo. Como son abundantes, suele darle 2 bananas y 1 naranja a su hermana. No obstante Miguel siempre quiere quedarse con por lo menos una naranja, por lo cual le da una naranja a su hermana sólo cuando se cosechan al menos 2 naranjas.

Miguel ahora quiere modernizarse, compró una cinta transportadora que detecta cada fruta que la atraviesa y te pide ayuda para  escribir un programa que reciba el código generado por la máquina y *devuelva la cantidad de bananas y naranjas que le quedarán* luego de quitar las frutas que le dará a su hermana.

```python
ejemploCodigoDePedido = "BBBBBNNNNNNNN"
```

Cada `N` representa una naranja y cada `B` representa una banana.

**Ejemplos:**

 * Miguel tenía 5 bananas y 8 naranjas y le da 2 bananas y 1 naranja a su hermana:

 `miguelito( "BBBBBNNNNNNNN" )` → `3 Bananas y 7 Naranjas`
 
 * Miguel le da su única banana a la hermana pero no está dispuesto a quedarse sin naranjas:

 `miguelito( "BN" )` → `0 Bananas y 1 Naranja`



###$\normal$ Dame una señal

En este ejercicio se analizarán los datos **reales** de un filtro electrónico pasa-altos (atenúa las frecuencias bajas).

**No es necesario** saber nada acerca de este tema para lograr hacer el análisis, este conjunto de datos se manipula simplemente como cualquier otro.

Para obtener los datos, se construyó el circuito y se midió el *voltaje* en la entrada del sistema y el *voltaje* en la salida del sistema utilizando un instrumento de medición llamado *osciloscopio*:

<img src="https://raw.githubusercontent.com/IEEESBITBA/Curso-Python/master/_assets/osciloscopio.jpg" alt = "Foto de un osciloscopio" height = 200>

Este instrumento tiene la funcionalidad de exportar los datos en un formato llamado **CSV**.

**CSV** (valores separados por comas) es un formato de archivo usado frecuentemente para almacenar datos en forma de tabla. Cada renglón corresponde a una fila, y en cada fila se separan las columnas usando comas. Una pequeña limitación es que dado que se usan para delimitar columnas, no admite el uso de comas como parte del contenido de los elementos.

- Importar el archivo **mediciones.csv**

! wget "https://raw.githubusercontent.com/IEEESBITBA/Curso-Python/master/Curso_Introductorio_Datos/mediciones.csv"

Si descargan este archivo y lo abren con el *bloc de notas* o algún otro editor de texto, verán que las primeras lineas comienzan con '**#**', ya que se tratan de comentarios. Luego hay una línea vacía, y a continuación aparecen los nombres de cada columna. A partir de entonces, cada renglón contiene 3 números separados por comas.

Los nombres de las columnas son:
- Time (s)
- Channel 1 (V)
- Channel 2 (V)

La primer columna contiene el instante de tiempo en el cual se efectuó cada medición, la segunda columna contiene los valores de la señal de entrada del sistema, y la tercer columna contiene los valores de la señal de salida del sistema. A continuación se representan estos mismos datos mediante un gráfico en función del tiempo:

<img src="https://raw.githubusercontent.com/IEEESBITBA/Curso-Python/master/_assets/highpass.png" alt = "Gráfico del filtro pasa-bajos" height = 250>

*Este gráfico se generó utilizando Python y matplotlib, esta herramienta se explica en otro curso que ofrecemos en IEEE-ITBA.*

\

**Identificar y mostrar en pantalla:**
- El valor más alto de cada columna
- El valor más bajo de cada columna
- El valor promedio de cada columna

$\dificil$ *Challenge*:
- Los instantes de tiempo en los cual la señal *Channel 1* pasa de un valor negativo a un valor positivo
- El intervalo de tiempo entre cada uno de estos sucesos (el periodo de la señal)


file = open("mediciones.csv") # cargamos el archivo a la variable file

contenido = file.readlines() # obtenemos todas las lineas

###$\normal$ El código secreto
<img class="img" src="https://raw.githubusercontent.com/IEEESBITBA/Curso-python/master/_assets/vacas.jpg" height="250" alt = "Vacas y toros" title = "Vacas">

En un país desconocido los agentes secretos se comunican mediante un código numerico. La característica principal del código es que el transmisor no puede decir el número, sino que, con un conjunto de reglas, el recepto debe adivinar el número.

Cada vez que el agente indique un número con el objetivo de adivinar, el segundo agente debe indicar:
  * Como **correctos** la cantidad de dígitos que aparecen en su propio número y en el del otro agente, en las **mismas posiciones**.
  * Indica como **mal ubicados** la cantidad de dígitos que aparecen en ambos números, pero no en las mismas posiciones. 

La idea de este ejercicio es programar lo que sería el agente emisor del mensaje. Para ello, el programa deberá elegir de forma aleatoria un número de 5 cifras y, cada vez que el usuario le ingrese un número por consola, deberá indicar la cantidad de **correctos** y **mal ubicados**. 
El programa termina cuando el usuario adivina el número. 

**Ejemplos**:
- Supongamos que la máquina eligió el número `39541` y el usuario dijo `19421`. Entonces la máquina debería responder 2 **correctos** ( el último "1" y el "9") y 2 **mal ubicados** (el "4" y el primer "1").

- Supongamos que la máquina eligió el número `9955` y el usuario dijo `9559`. Entonces la máquina debería responder 2 **correctos** (por el primer "9" y el segundo "5") y 2 **mal ubicados** (por el primer "5" y por el segundo "9").

***********************************************

Programar un juego en el que la computadora elige un número de 5 dígitos que el usuario debe adivinar. Para ello, por cada ronda el usuario indica un número y la máquina:
* Indica como **vacas** la cantidad de dígitos que aparecen en el número del usuario y de la máquina, en las mismas posiciones.
* Indica como **toros** la cantidad de dígitos que aparecen en ambos números, pero no en las mismas posiciones. 

El juego termina cuando el usuario adivina el número.

**Ejemplos**:
- Supongamos que la máquina eligió el número `39541` y el usuario dijo `19421`. Entonces la máquina debería responder 2 vacas ("1" y "9") y 2 toros ("4" y "1").

- Supongamos que la máquina eligió el número `9955` y el usuario dijo `9559`. Entonces la máquina debería responder 2 vacas (por el primer "9" y el segundo "5") y 2 toros (por el primer "5" y por el segundo "9").

**Tips:**
- Convertir todos los números a *string* o a *list* puede ayudarlos a realizar comparaciones:
 ```python
 texto = str(123456)
 lista = list(texto)
 ```

- Pueden elegir el número original de la forma que prefieran. Una alternativa que todavía no se explicó en el curso es usando [librerías](https://docs.python.org/3/library/random.html#random.randint):

 ```python
 import random
 numero = random.randint(10000, 99999)
 ```




### $\dificil$ Análisis estadístico de fallas en lotes de producción

Una planta de producción de botellas plásticas fabrica 1000 lotes de botellas por día. Debido al proceso de fabricación algunas de las botellas salen falladas, estos fallos son detectados automáticamente durante el proceso de control de calidad y se cargan en una base de datos que registra la cantidad de productos fallados que fueron detectados por cada lote. El departamento de control de calidad sospecha que la cantidad de fallos por lote sigue una distribución de *Poisson*, pero todavía no conocen la media y la varianza.

Se pide importar los datos de los últimos 30 días (en total son 30000 datos) y calcular la *media*, la *varianza*, la *moda* y la *mediana* de la distribución de datos medidos (sin utilizar librerías de estadística). Los datos se encuentran en el archivo *ControlCalidadBotellas.csv* bajo la columna *Fallas*, recomendamos hacer *print()* del contenido del archivo o abrir el archivo con un editor de texto para comprender mejor el formato en el que se encuentran los datos.

**Definiciones:**
- **Media:** El valor promedio:

  $\mu=\frac{X_1+X_2+X_3+\cdots+X_n}{n}$

- **Varianza:** El promedio de las distancias al cuadrado entre cada valor y la media:

  $\sigma^2=\frac{(X_1-\mu)^2+(X_2-\mu)^2+\cdots+(X_n-\mu)^2}{n}$

- **Moda:** El valor que ocurre con mayor frecuencia.

- **Mediana:** El valor que cumple la propiedad que la mitad de las veces el valor medido es menor a la mediana y la otra mitad de las veces es mayor.

Si las sospechas acerca de la distribución fueran correctas, entonces de acuerdo a las propiedades de la distribución de Poisson la media y la varianza deberían ser iguales, además la moda sería $\lceil{\mu}\rceil-1$
¿Esta sospecha les parece acertada?

\

**Tips:**
- Usando las librerías numpy y scipy se pueden realizar todo tipo de análisis de estadística sin tener que programar todo a mano! Este es sólo un ejercicio para practicar la manipulación de datos.

! wget "https://raw.githubusercontent.com/IEEESBITBA/Curso-Python/master/Curso_Introductorio_Datos/ControlCalidadBotellas.csv"



###$\dificil$ Convirtiendo números

Después de usar tantas veces la instrucción ``int()`` para realizar conversiones, uno empieza a preguntarse ¿Será muy complicado convertir textos a números?

Para poner esto a prueba, les proponemos crear su propio ``int()``. Para lograrlo deben definir una funcion ``text2number()`` que reciba como parámetro una variable de tipo *string* y devuelva un número entero correspondiente a la conversión, tal como funciona ``int()``. Los requisitos que debe cumplir la entrada para ser considerada válida son:
 - Al inicio puede contener o no cierta cantidad de espacios ``' '``.
 - Luego puede o no tener 1 caracter de signo: ``'+'`` ó ``'-'``.
 - Luego tiene cierta cantidad de caracteres numéricos: entre ``'0'`` y ``'9'``.
 - Por último puede contener o no cierta cantidad de espacios ``' '``.

Como buena práctica de programación, les recomendamos considerar diferentes casos límites para verificar que el código logra manejarlos adecuadamente, además de ejemplos válidos también comprobar donde las condiciones no se cumplen o estan en el límite de cumplirse. De esa forma pueden asegurarse de que su código hace lo que esperaban en todo tipo de situaciones.

Quedará a su criterio definir lo que hace la función cuando la entrada no se considera válida.

**Tips:**
* Al igual que las listas, los strings son "iterables". Los tipos de datos "iterables" permiten, entre otras cosas, realizar un *for* que recorre todos sus elementos:
```python
texto = "Hola Mundo!"
for letra in texto:
    print(letra)
```
* Usando el comando ``ord()`` se obtiene el [código ASCII](https://es.wikipedia.org/wiki/ASCII) de un caracter, y restando ``ord('0')`` se obtiene el valor numérico de un caracter entre ``'0'`` y ``'9'``:
```python
caracter = '5'
numero = ord(caracter) - ord('0')
```



###$\imposible$ TicTacToe

<img class="img" src="https://raw.githubusercontent.com/IEEESBITBA/Curso-python/master/_assets/tictactoe.png" height="200" alt = "TicTacToe" title = "TicTacToe">



Desarrollar un juego Ta-Te-Ti en el cual dos usuarios se enfrenten. Por cada turno, un usuario (al que le corresponda) deberá indicar por consola con un número del 1 (casilla superior izquierda) al 9 (casilla inferior derecha) en función de la casilla en que quiere colocar su ficha. El juego termina cuando un jugador coloca 3 fichas en línea o ya no se pueden colocar más fichas. Al finalizar la partida, indicar qué jugador ganó o si hubo empate.

**Ayuda**: Facilitamos la función ```drawboard``` para poder mostrar el tablero en pantalla.

**Recomendación**: Modularizar el programa en diferentes módulos, por ejemplo: uno que revise si hay un jugador ganador o no, otro que gestione los datos que ingresan los jugadores y los guarde en la lista, etc.

# drawboard() recibe una lista de 9 elementos donde
# los elementos de la lista son cruces, círculos, o espacios

def drawboard(board):
  print(' ', board[0], ' | ', board[1], ' | ', board[2] ) #Dibujamos el 1er renglón
  print('-----------------')
  print(' ', board[3], ' | ', board[4], ' | ', board[5] ) #Dibujamos el 2do renglón
  print('-----------------')
  print(' ', board[6], ' | ', board[7], ' | ', board[8] ) #Dibujamos el 3er renglón

# Anexo A: Funcionamiento de la memoria
La lectura de los Anexos es **100% opcional** y NO es un requisito para continuar con el curso.


En la explicación al principio de la clase representamos la memoria como un conjunto de casilleros que almacenan números, vamos a explicar un poco más en detalle de dónde salen esos números, y por qué es la única manera de almacenar información en la memoria.

La memoria de una computadora es un dispositivo que contiene un conjunto de componentes electrónicos que pueden alternar entre 2 estados, un estado de encendido y uno de apagado. La computadora puede dar instrucciones a la memoria para modificar el estado de estos componentes, de forma que determine si cada uno está encendido o apagado, y más tarde puede revisar estos componentes para saber el estado en el que están. De alguna forma tenemos que usar las distintas combinaciones de encendidos y apagados (también llamados 0 y 1) de los distintos componentes para representar toda la información que necesitamos. Cada uno de estos "pedacitos" de información que únicamente tienen 2 estados se los llama "digitos binarios" o "bits", y como dijimos anteriormente cada *bit* puede valer 0 o 1.

En los comienzos de la informática se adoptó una convención que es ahora casi universal, esta gran cantidad de *bits* que tiene la memoria se van a separar en grupos de 8. Cada "casillero" de la memoria en la imagen de la explicación del inicio, corresponde a un grupo de 8 *bits* de memoria, es decir, a 8 de estos componentes que pueden estar encendidos o apagados.

&ensp;*¿Entonces por qué dijimos que cada casillero es un número, cuando es realidad son 8 dígitos binarios?*

La respuesta es que es mucho más fácil usar números decimales (los números "normales") en lugar de 8 dígitos binarios, entonces interpretamos esos 8 *bits* como un número decimal usando el [sistema binario](https://es.wikipedia.org/wiki/Sistema_binario). Usando este sistema, cada combinación de 8 *bits*, es decir 8 ceros y unos, corresponde a un número decimal.

Por ejemplo:

| Binario | Decimal   |
|----------|-----|
| 00000000 | 0   |
| 00000001 | 1   |
| 00000010 | 2   |
| 00000011 | 3   |
| ...      | ... |
| 11111111 | 255 |

<br />

Usando 8 *bits* se pueden generar 256 combinaciones distintas, y en el sistema decimal corresponden a los números del 0 al 255. Cada uno de estos paquetes de 8 *bits* se denomina "byte", cuando nos referíamos a un "casillero" de memoria en realidad estabamos haciendo referencia a un *byte*.

Para guardar números mayores a 255, la variable correspondiente deberá ocupar más de 1 *byte* o "casillero". Cuándo se utilizan 2 *bytes* para almacenar un número, una estrategia posible es usar un *byte* para almacenar el cociente N/256 y el otro para almacenar el resto N%256 (en donde N es el número que se desea guardar). Luego para recrear el número original se multiplica el cociente por 256 y se suma el resto. Este es sólo un ejemplo, se utilizan diferentes estrategias para almacenar números negativos, números con decimales, y más.

Otro tipo de variables como strings, listas, sets, etc. utilizan diferentes técnicas. En algunos casos se reserva una cantidad grande de *bytes* por si el tamaño de la variable crece mucho, en algunos casos se pueden reservar más *bytes* si la cantidad reservada previamente no es suficiente.

Hay muchos más detalles acerca de cada una de las cosas que mencionamos, y de cada tema se podrían hacer varias clases enteras, por lo cual si quieren conocer más pueden seguir investigando por su cuenta.

Algunos links interesantes:

https://es.wikipedia.org/wiki/ASCII

https://es.wikipedia.org/wiki/Unicode

https://es.wikipedia.org/wiki/Byte

https://es.wikipedia.org/wiki/Coma_flotante

https://es.wikipedia.org/wiki/Direcci%C3%B3n_de_memoria

https://es.wikipedia.org/wiki/Puntero_(inform%C3%A1tica)

https://es.wikipedia.org/wiki/Biestable

# Anexo B: Instalación de Python y uso de IDEs
La lectura de los Anexos es **100% opcional** y NO es un requisito para continuar con el curso.

A continuación les dejamos un fragmento de una transmisión en vivo de años anteriores, en la cual se da una introducción al uso de Entornos de Desarrollo Integrados (IDEs) y cómo utilizar algunas herramientas básicas como un debugger.

# Link a Youtube: https://www.youtube.com/watch?v=hpdHpKyxLY4

from IPython.display import YouTubeVideo
YouTubeVideo('hpdHpKyxLY4', start=400, end=1768, width=800, height=450)

# Anexo C: Git (control de versiones)
La lectura de los Anexos es **100% opcional** y NO es un requisito para continuar con el curso.

A continuación les dejamos un fragmento de una transmisión en vivo de años anteriores, en la cual se da una introducción al control de versiones con Git.

# Link a Youtube: https://www.youtube.com/watch?v=hpdHpKyxLY4

from IPython.display import YouTubeVideo
YouTubeVideo('hpdHpKyxLY4', start=1768, end=3295, width=800, height=450)

#Sponsors 
Agradecemos a nuestros sponsors por facilitarnos la posibilidad de brindar este curso.

<img height="100" src="https://raw.githubusercontent.com/IEEESBITBA/Curso-python/master/_assets/SPONSOR_JPM.png">
<img height="100" src="https://raw.githubusercontent.com/IEEESBITBA/Curso-python/master/_assets/SPONSOR_Flowics.png">
